{
  "hash": "2e92c85def481c1866143f2e10186239",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exercice 4.03\"\nauthor: \"Clément Poupelin\"\ndate: \"2025-03-xx\"\ndate-modified: \"2025-03-07\"\nformat: \n  html:\n    embed-resources: false\n    toc: true\n    code-fold: true\n    code-summary: \"Show the code\"\n    code-tools: true\n    toc-location: right\n    page-layout: article\n    code-overflow: wrap\ntoc: true\nnumber-sections: false\neditor: visual\ncategories: [\"Fiche 4\"]\nimage: \"\"\ndescription: \"\"\n---\n\n\n\n# Intervenant.e.s\n\n### Rédaction\n\n-   **Clément Poupelin**, [clementjc.poupelin\\@gmail.com](mailto:clementjc.poupelin@gmail.com){.email}\\\n\n### Relecture\n\n-   \n\n# Setup\n\n:::: panel-tabset\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Données\nlibrary(dplyr)        # manipulation des données\n\n# Esthétique\nlibrary(latex2exp)   ## TeX\nlibrary(ggplot2)     ## ggplot\n```\n:::\n\n\n\n## Fonctions\n\n::: panel-tabset\n\n### Série temporelle simulée\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSim_AR2 <- function(n, a, b) {\n  eps <- rnorm(n + 100)\n  x <- rnorm(n + 100) \n  for (i in (3:(n + 100))) {\n    x[i] <- eps[i] - a * x[i - 1] - b * x[i - 2]\n  }\n  ar2 <- x[101:(n + 100)]\n  return(ts(ar2))\n}\n```\n:::\n\n\n\n### Plot de séries temporelles\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggTimeSerie <- function(ts, main_title = NULL) {\n  df_series <- data.frame(Time = as.numeric(time(ts)), TimeSerie = ts)\n  colnames(df_series) <- c(\"Time\", \"TimeSerie\")\n  \n  if(is.null(main_title)){\n    main <- latex2exp::TeX(paste0(\"Série $( x_t )_{t=0, ...,n}$ avec n = \", length(ts)))\n  } else \n    main <- latex2exp::TeX(main_title)\n  \n  p <- ggplot(df_series, aes(x = Time, y = TimeSerie)) +\n    geom_line(color = \"red\") + \n    labs(title = main,\n    x = \"Time\",\n    y = \"Simulated series\") +\n    theme_minimal() \n  \n  if(length(time(ts(ts))) == length(ts)){\n    p <- p\n  } else\n    p <- p +\n    scale_x_continuous(\n    breaks = seq(floor(min(df_series$Time)), ceiling(max(df_series$Time)), by = 2),  \n    labels = function(x) floor(x)  \n  )\n  \n  return(p)\n}\n```\n:::\n\n\n\n\n### Plot pour ACF et PACF\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggACF <- function(ts) {\n  acf_data <- acf(ts, plot = FALSE)\n  df_acf <- data.frame(Lag = acf_data$lag, ACF = acf_data$acf)\n  \n  pacf_data <- pacf(ts, plot = FALSE)\n  df_pacf <- data.frame(Lag = pacf_data$lag, PACF = pacf_data$acf)  \n  \n  # Intervalle de confiance\n  ci <- qnorm((1 + 0.95) / 2) / sqrt(length(ts))\n  \n  # ACF \n  p_acf <- ggplot(df_acf, aes(x = Lag, y = ACF)) +\n    geom_segment(aes(xend = Lag, yend = 0), color = \"red\") +\n    geom_point(color = \"red\") +\n    labs(title = \"Autocorrelation Function (ACF)\", x = \"Lag\", y = \"ACF\") +\n    geom_hline(yintercept = c(-ci, ci), color = \"blue\", linetype = \"dashed\") +\n    theme_minimal()\n  \n  # PACF \n  p_pacf <- ggplot(df_pacf, aes(x = Lag, y = PACF)) +  \n    geom_segment(aes(xend = Lag, yend = 0), color = \"red\") +\n    geom_point(color = \"red\") +\n    labs(title = \"Partial Autocorrelation Function (PACF)\", x = \"Lag\", y = \"PACF\") +\n    geom_hline(yintercept = c(-ci, ci), color = \"blue\", linetype = \"dashed\") +\n    theme_minimal()\n  \n  return(list(ACF = p_acf, PACF = p_pacf))\n}\n```\n:::\n\n\n\n\n:::\n\n## Seed\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(140400)\n```\n:::\n\n\n::::\n\n# Données\n\nDans cette exo nous allons travailler sur 3 modèles du type AR(2) avec des coefficient +,+ ou -, - ou +, -.\n\n- $X_t + 1.6X_{t-1} + .64X_{t-2} = w_t$\n\n- $X_t - .4X_{t-1} - .45X_{t-2} = w_t$\n\n- $X_t - 1.2X_{t-1} + .85X_{t-2} = w_t$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100\na1 <- c(1.6, -0.4, -1.2)\na2 <- c(0.64, -0.45, 0.85)\n\ngridExtra::grid.arrange(\n  ggTimeSerie(\n    Sim_AR2(n, a1[1], a2[1]),\n    main_title = paste0(\"Série AR(2) avec a1 = \", a1[1], \" et a2 = \", a2[1])\n  ),\n  ggTimeSerie(\n    Sim_AR2(n, a1[2], a2[2]),\n    main_title = paste0(\"Série AR(2) avec a1 = \", a1[2], \" et a2 = \", a2[2])\n  ),\n  ggTimeSerie(\n    Sim_AR2(n, a1[3], a2[3]),\n    main_title = paste0(\"Série AR(2) avec a1 = \", a1[3], \" et a2 = \", a2[3])\n  ),\n  ncol = 3\n)\n```\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-5-1.png){width=1536}\n:::\n:::\n\n\n\n\n# Equation de récurrence \n\nPour les trois modèles AR(2) décrits ci-dessus, déterminer l’équations de récurrence\nsatisfaite par ACF $\\rho$ et donner la solution (en précisant toutes les constantes)\n\n# ACF \n\nNous allons maintenant utiliser les résultats théoriques précédents pour tracer les valeurs des l’ACF $\\rho(h))$ pour $h = 1...2$. Vérifier vos résultats en utilisant la fonction *`ARMAacf`*\n\n\n\n\n\n# Conclusion\n\n\n\n# Session info\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(pkgs = \"attached\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31)\n os       Ubuntu 24.04.1 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  fr_FR.UTF-8\n ctype    fr_FR.UTF-8\n tz       Europe/Paris\n date     2025-03-07\n pandoc   3.2 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/x86_64/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package   * version date (UTC) lib source\n dplyr     * 1.1.4   2023-11-17 [1] CRAN (R 4.4.2)\n ggplot2   * 3.5.1   2024-04-23 [1] CRAN (R 4.4.2)\n latex2exp * 0.9.6   2022-11-28 [1] CRAN (R 4.4.2)\n\n [1] /home/clement/R/x86_64-pc-linux-gnu-library/4.4\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n\n\n\nTracer les valeurs des l’ACF $\\rho(h)$ pour $h = 1, 2$ . Vérifier vos résultats en utilisant la fonction **ARMAacf**.\n\n<br>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On pose nos paramètres\na1 = c(1.6, -0.4, -1.2)\na2 = c(0.64, -0.45, 0.85)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[1], -a2[1]), ma = 0, lag.max = 2, pacf = FALSE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         0          1          2 \n 1.0000000 -0.9756098  0.9209756 \n```\n\n\n:::\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[2], -a2[2]), ma = 0, lag.max = 2, pacf = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        0         1         2 \n1.0000000 0.7272727 0.7409091 \n```\n\n\n:::\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[3], -a2[3]), ma = 0, lag.max = 2, pacf = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          0           1           2 \n 1.00000000  0.64864865 -0.07162162 \n```\n\n\n:::\n\n```{.r .cell-code}\n# lag.max = n fait calculer et afficher les n premières valeurs en partant de 0\n```\n:::\n\n\n\nPour $h = 1, 2$ on retrouve bien les valeurs calculées à la question 1.\n\n#### **BONUS** :\n\n<br>\n\nOn se propose de Généraliser en comparant les fonctions calculés en question 1 avec **ARMAacf** et la fonction **acf** de r, $\\forall h$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On code notre fonction AR(2)\nn = 100\n\n\nAR2 = function(n, a, b) {\n  eps = rnorm(n + 100)  \n  x = rnorm(n + 100) #c'est pour donner la taille mais après on remplacera toute les valeurs\n  # on suppose que X_0 est une rnorm\n  for (i in (3:(n + 100))) {\n    x[i] = eps[i] - a * x[i - 1] - b * x[i - 2]\n  }\n  X_final = x[101:(n + 100)]\n  return(X_final)  \n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# On code des fonction pour définir \\rho à partir des calculs de la question 1\n\nrho1 = function(h){\n  r = (-5/4)^(-h) * (1 + h * (9/41))\n  return(r)\n}\n\nrho2 = function(h){\n  r = (135/154) * (9/10)^h + (19/154) * (-1)^h * (1/2)^h\n  return(r)\n}\n\nrho3 = function(h){\n  mod_z1 = sqrt(340/289)\n  arg_z1 = atan(7/6)\n  A = ( ( (24/37) * sqrt(30/17) - cos(atan(7/6)) / sin(atan(7/6))) )^2\n  c1 = -sqrt(1+A)\n  c2 = acos(1/c1)\n  r = c1 * mod_z1^(-h) * cos(h * arg_z1 + c2)\n  return(r)\n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Exercice_04.03_files/figure-html/unnamed-chunk-12-6.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Exercice_04.03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}