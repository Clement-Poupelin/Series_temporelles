{
  "hash": "a7d6baeff3bc420f89ff9ab5aaf81b32",
  "result": {
    "markdown": "---\ntitle: \"Fiche 04\"\nauthor: \"Clément Poupelin\"\ndate: \"2025-02-xx\"\ndate-modified: \"2025-02-27\"\nformat: \n  html:\n    embed-resources: false\n    toc: true\n    code-fold: true\n    code-summary: \"Show the code\"\n    code-tools: true\n    toc-location: right\n    page-layout: article\n    code-overflow: wrap\ntoc: true\nnumber-sections: false\neditor: visual\ncategories: [\"categorie 1\", \"cotegorie 2\"]\nimage: \"\"\ndescription: \"Description\"\n---\n\n\n# Intervenant.e.s\n\n### Rédaction\n\n-   **Clément Poupelin**, [clementjc.poupelin\\@gmail.com](mailto:clementjc.poupelin@gmail.com){.email}\\\n\n### Relecture\n\n-   \n\n# Setup\n\n:::: panel-tabset\n## Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Données\nlibrary(dplyr)        # manipulation des données\n\n\n# Plots\n## ggplot\nlibrary(ggplot2)\nlibrary(gridExtra)\n```\n:::\n\n\n## Fonctions\n\n::: panel-tabset\n### Fonction 1\n\n### Fonction 2\n:::\n\n## Seed\n::::\n\n# Données\n\n# Analyse\n\n::: callout-note\nMETTRE LES REMARQUES\n:::\n\n::: callout-warning\nMETTRE LES POINTS D'ATTENTION\n:::\n\n:::: success-header\n::: success-icon\n:::\n\nRésultats\n::::\n\n::: success\nMETTRE LES CONCLUSIONS\n:::\n\n# Conclusion\n\n# Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(pkgs = \"attached\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23 ucrt)\n os       Windows 10 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  French_France.utf8\n ctype    French_France.utf8\n tz       Europe/Paris\n date     2025-02-27\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package   * version date (UTC) lib source\n dplyr     * 1.1.4   2023-11-17 [1] CRAN (R 4.2.3)\n ggplot2   * 3.5.1   2024-04-23 [1] CRAN (R 4.2.3)\n gridExtra * 2.3     2017-09-09 [1] CRAN (R 4.2.1)\n\n [1] C:/Users/cleme/AppData/Local/R/win-library/4.2\n [2] C:/Program Files/R/R-4.2.1/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n\n\n# **EXERCICE 3 : **\n<br>\n\n\n#### QUESTION 2 : Tracer les valeurs des l’ACF $\\rho(h)$ pour $h = 1, 2$ . Vérifier vos résultats en utilisant la fonction **ARMAacf**.\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On pose nos paramètres\na1 = c(1.6, -0.4, -1.2)\na2 = c(0.64, -0.45, 0.85)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[1], -a2[1]), ma = 0, lag.max = 2, pacf = FALSE) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         0          1          2 \n 1.0000000 -0.9756098  0.9209756 \n```\n:::\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[2], -a2[2]), ma = 0, lag.max = 2, pacf = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        0         1         2 \n1.0000000 0.7272727 0.7409091 \n```\n:::\n\n```{.r .cell-code}\nARMAacf(ar = c(-a1[3], -a2[3]), ma = 0, lag.max = 2, pacf = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          0           1           2 \n 1.00000000  0.64864865 -0.07162162 \n```\n:::\n\n```{.r .cell-code}\n# lag.max = n fait calculer et afficher les n premières valeurs en partant de 0\n```\n:::\n\n\n\nPour $h = 1, 2$ on retrouve bien les valeurs calculées à la question 1.\n\n#### **BONUS** :\n<br>\n\n\nOn se propose de Généraliser en comparant les fonctions calculés en question 1 avec **ARMAacf** et la fonction **acf** de r, $\\forall h$. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On code notre fonction AR(2)\nn = 100\n\n\nAR2 = function(n, a, b) {\n  eps = rnorm(n + 100)  \n  x = rnorm(n + 100) #c'est pour donner la taille mais après on remplacera toute les valeurs\n  # on suppose que X_0 est une rnorm\n  for (i in (3:(n + 100))) {\n    x[i] = eps[i] - a * x[i - 1] - b * x[i - 2]\n  }\n  X_final = x[101:(n + 100)]\n  return(X_final)  \n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# On code des fonction pour définir \\rho à partir des calculs de la question 1\n\nrho1 = function(h){\n  r = (-5/4)^(-h) * (1 + h * (9/41))\n  return(r)\n}\n\nrho2 = function(h){\n  r = (135/154) * (9/10)^h + (19/154) * (-1)^h * (1/2)^h\n  return(r)\n}\n\nrho3 = function(h){\n  mod_z1 = sqrt(340/289)\n  arg_z1 = atan(7/6)\n  A = ( ( (24/37) * sqrt(30/17) - cos(atan(7/6)) / sin(atan(7/6))) )^2\n  c1 = -sqrt(1+A)\n  c2 = acos(1/c1)\n  r = c1 * mod_z1^(-h) * cos(h * arg_z1 + c2)\n  return(r)\n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-8-6.png){width=672}\n:::\n:::\n\n\n\n<br>\n\n# **EXERCICE 5 : **\n<br>\n\n\n#### QUESTION 3 : Pour les modèles AR(2) définis à l’exercice 3, Simuler une trajectoire (avec $n=100$) pour les 3 modèles, puis calculer et représenter le prédicteur pour $h=1,...,10$ (avec un intervalle de confiance). \n<br>\n\n\nOn se base sur les 3 processus AR(2) définit en questions 3\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fonction pour simuler et prévoir\nsimu_and_pred = function(coef1, coef2){\n  # simulations\n  X_t = AR2(n, coef1, coef2) # On utilise notre fonction AR2\n  \n  # prévisions\n  Prev = vector(\"numeric\", length = 12)\n  Prev[1] = X_t[n-1] # horizon h = -1\n  Prev[2] = X_t[n] # horizon h = 0\n  \n  # horizon h = 1, ..., 10\n  for(k in 3:12){\n    Prev[k] = -coef1 * Prev[k-1]  -coef2 * Prev[k-2]\n  }\n  \n  # erreurs\n  \n  # ARMAtoMA donne (psi_1, ..., psi_lag.max) :\n  # il faut donc ajouter psi_0 = 1\n    erreurs = cumsum(c(1, ARMAtoMA(ar = c(-coef1,- coef2), lag.max = 9)^2))\n  \n  # Intervalles de prévision :\n  \n  # IC à 95% \n  alpha_95 = 0.05\n  q_alpha_95 = qnorm(1 - alpha_95/2)\n  # bornes inf des intervalles de prévison\n  l_95 = Prev[3:12] - q_alpha_95 * sqrt(erreurs) \n  # bornes sup des intervalles de prévison\n  u_95 = Prev[3:12] + q_alpha_95 * sqrt(erreurs) \n  \n  # IC à 80%\n  alpha_80 = 0.2\n  q_alpha_80 = qnorm(1 - alpha_80/2) \n  l_80 = Prev[3:12] - q_alpha_80 * sqrt(erreurs) \n  u_80 = Prev[3:12] + q_alpha_80 * sqrt(erreurs) \n  \n  return(list(X_t = X_t, \n              Prev = Prev[3:12], \n              lower = list(l_80 = l_80, l_95 = l_95),\n              upper = list(u_80 = u_80, u_95= u_95)))\n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Fiche_04_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n:::",
    "supporting": [
      "Fiche_04_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}